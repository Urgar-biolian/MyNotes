## 本周学习内容总结

### 一维动态规划

1. **硬币找零问题**
   - 问题描述：计算凑出金额n所需的最小硬币数量
   - 关键思路：
     - dp[i]表示凑出金额i的最小硬币数
     - 状态转移方程：dp[i] = min(dp[i], dp[i-coin]+1) for coin in coins
     - 初始化：dp[0]=0，其他初始化为极大值
2. **爬楼梯问题（带障碍）**
   - 问题描述：计算到达第n阶楼梯的方法数，某些楼梯损坏不能踩
   - 关键思路：
     - dp[i]表示到达第i阶的方法数
     - 状态转移：dp[i] = dp[i-1] + dp[i-2]（前提是前序台阶可用）
     - 初始化：dp[0]=1（作为基准条件）

### 二维动态规划

1. **网格路径计数**
   - 问题描述：计算从网格左上到右下的路径数
   - 关键思路：
     - dp[i][j]表示到达(i,j)的路径数
     - 状态转移：dp[i][j] = dp[i-1][j] + dp[i][j-1]
     - 边界处理：第一行和第一列初始化为1
2. **传球问题**
   - 问题描述：计算m次传球后球回到起点的方案数
   - 关键思路：
     - dp[i][j]表示第i次传球到j号同学的方案数
     - 状态转移：dp[i][j] = dp[i-1][(j+1)%n] + dp[i-1][(j-1+n)%n]
     - 环形处理：使用模运算处理环形结构

### 树形动态规划

1. **基本特征**：

   - 问题模型建立在树形结构上
   - 子问题通常对应子树的最优解
   - 通过后序遍历实现自底向上的计算

2. **解题框架**：

   ```java
   void treeDP(TreeNode node) {
       // 1. 递归处理所有子节点
       for (TreeNode child : node.children) {
           treeDP(child);
       }
       
       // 2. 根据子树结果计算当前节点状态
       // [状态转移逻辑]
   }
   ```

### 经典树形DP问题

1. **二叉树最大路径和**
   - 状态定义：
     - dp[node]：以node为根的子树的最大路径和
     - 可能包含三种情况：当前节点值、左子树路径+节点、右子树路径+节点
2. **树的重心问题**
   - 计算删除某节点后最大连通块的最小值
   - 需要维护子树大小size[node]
3. **树形背包问题**
   - 在树上进行资源分配（如节点染色问题）
   - 典型状态：dp[node][k]表示在node子树使用k资源的最优解

## 重点

### 树形DP与线性DP的区别

|     特征     |  线性DP   |    树形DP    |
| :----------: | :-------: | :----------: |
|   数据结构   | 数组/序列 |    树结构    |
|   遍历方式   | 顺序/逆序 |   后序遍历   |
| 状态转移方向 | 单向递推  | 子树→根节点  |
|  典型初始化  | 边界条件  | 叶子节点条件 |

### 关键技巧

1. **多状态设计**：

   - 通常需要维护多个状态（如选择/不选择当前节点）

   - 示例：节点选中的最大独立集问题

     ```java
     dp[node][0] = sum(max(dp[child][0], dp[child][1]))  # 不选当前节点
     dp[node][1] = node.val + sum(dp[child][0])          # 选择当前节点
     ```

2. **二次扫描法**：

   - 用于解决需要考虑父节点信息的问题
   - 第一次后序遍历获取子树信息
   - 第二次前序遍历结合父节点信息

## 下周学习计划

1. **基础暴力方法**
   - 排列组合生成（全排列、子集）
   - 多重循环穷举
   - 二进制枚举技巧
2. **典型暴力题型**
   - 网格DFS/BFS暴力搜索
   - 字符串匹配暴力解法
   - 简单数学问题枚举